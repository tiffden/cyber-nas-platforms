#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
UI_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
SPKI_ROOT="$(cd "$UI_ROOT/../.." && pwd)"
SPKI_BIN_DIR="$SPKI_ROOT/_build/default/bin"
# Keep harness data out of the repo and away from normal runtime state by default.
HARNESS_ROOT="${SPKI_REALM_HARNESS_ROOT:-$HOME/.cyberspace/testbed}"
HARNESS_LOG_FILE="${SPKI_REALM_HARNESS_LOG_FILE:-$HARNESS_ROOT/harness.log}"
DEFAULT_NODES=3
DEFAULT_REALM_NAME="${SPKI_REALM_HARNESS_NAME:-local-realm}"
DEFAULT_MASTER_HOST="${SPKI_REALM_HARNESS_HOST:-127.0.0.1}"
DEFAULT_MASTER_PORT="${SPKI_REALM_HARNESS_PORT:-7780}"

json_escape() {
  local value="${1:-}"
  value="${value//\\/\\\\}"
  value="${value//\"/\\\"}"
  value="${value//$'\n'/\\n}"
  printf "%s" "$value"
}

log_event() {
  local level="$1"
  local action="$2"
  local result="$3"
  local message="${4:-}"
  local request_id="${SPKI_REQUEST_ID:-n/a}"
  local ts
  ts="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

  local line
  line="{\"ts\":\"$(json_escape "$ts")\",\"level\":\"$(json_escape "$level")\",\"component\":\"realm_harness\",\"action\":\"$(json_escape "$action")\",\"result\":\"$(json_escape "$result")\",\"request_id\":\"$(json_escape "$request_id")\",\"pid\":\"$$\""
  if [[ -n "$message" ]]; then
    line="${line},\"message\":\"$(json_escape "$message")\""
  fi
  line="${line}}"

  echo "$line" >&2
  mkdir -p "$(dirname "$HARNESS_LOG_FILE")" >/dev/null 2>&1 || true
  echo "$line" >>"$HARNESS_LOG_FILE" 2>/dev/null || true
}

usage() {
  cat <<EOF
Usage: $(basename "$0") <command> [args]

Commands:
  init [N]           Create N isolated node workdirs (default: ${DEFAULT_NODES})
  status [N]         Show realm status for each node
  self-join [N]      Join node1 to the configured realm endpoint
  invite-all [N]     Join nodes 2..N to node1 (${DEFAULT_MASTER_HOST}:${DEFAULT_MASTER_PORT})
  join-all [N]       Alias for invite-all
  ui <NODE_ID>       Launch one SwiftUI instance using NODE_ID environment
  ui-all-bg [N]      Launch N SwiftUI instances in background with isolated env
  stop-all-bg [N]    Stop background SwiftUI instances started by ui-all-bg
  env <NODE_ID>      Print node env file path
  clean              Remove harness data at ${HARNESS_ROOT}

Notes:
  - Each node gets separate vault/key/identity state under:
      ${HARNESS_ROOT}/node<id>/
  - UI launch reuses run-local.sh with SPKI_ENV_FILE + SPKI_SKIP_BUILD=1.
EOF
}

resolve_spki_bin() {
  local base="$1"
  local exe_path="$SPKI_BIN_DIR/$base.exe"
  local plain_path="$SPKI_BIN_DIR/$base"
  if [[ -x "$exe_path" ]]; then
    printf "%s" "$exe_path"
    return 0
  fi
  if [[ -x "$plain_path" ]]; then
    printf "%s" "$plain_path"
    return 0
  fi
  echo "Error: missing executable for $base" >&2
  echo "Checked: $exe_path" >&2
  echo "Checked: $plain_path" >&2
  echo "Run: cd $SPKI_ROOT && dune build" >&2
  exit 1
}

node_dir() {
  local id="$1"
  printf "%s/node%s" "$HARNESS_ROOT" "$id"
}

node_env_file() {
  local id="$1"
  printf "%s/node.env" "$(node_dir "$id")"
}

write_node_env() {
  local id="$1"
  local dir
  dir="$(node_dir "$id")"
  local workdir="$dir/work"
  local keydir="$dir/keys"
  local logdir="$dir/logs"
  local node_name
  node_name="$(resolve_node_name "$id")"
  local port=$((DEFAULT_MASTER_PORT + id - 1))

  mkdir -p "$workdir" "$keydir" "$logdir"
  : >"$logdir/node.log"
  : >"$logdir/realm.log"
  rm -f "$logdir/ui.pid"

  cat >"$(node_env_file "$id")" <<EOF
# Generated by realm-harness.sh for node ${id}
SPKI_REALM_WORKDIR="${workdir}"
SPKI_KEY_DIR="${keydir}"
SPKI_NODE_ID="${id}"
SPKI_NODE_NAME="${node_name}"
SPKI_NODE_PORT="${port}"
SPKI_REALM_NAME="${DEFAULT_REALM_NAME}"
SPKI_JOIN_HOST="${DEFAULT_MASTER_HOST}"
SPKI_JOIN_PORT="${DEFAULT_MASTER_PORT}"
SPKI_REALM_HARNESS_ROOT="${HARNESS_ROOT}"
SPKI_TESTBED_MODE="1"
SPKI_CHEZ_LIBDIR="${SPKI_ROOT}/scheme/chez"
SPKI_CHEZ_SCRIPT="${SPKI_ROOT}/scheme/chez/spki-realm.sps"
SPKI_CHEZ_STATUS_SCRIPT="${SPKI_ROOT}/scheme/chez/spki-status.sps"
SPKI_CHEZ_SHOW_SCRIPT="${SPKI_ROOT}/scheme/chez/spki-show-bridge.sps"
SPKI_CHEZ_KEYGEN_SCRIPT="${SPKI_ROOT}/scheme/chez/spki-keygen.sps"
SPKI_CHEZ_CERTS_SCRIPT="${SPKI_ROOT}/scheme/chez/spki-certs.sps"
SPKI_CHEZ_AUTHZ_SCRIPT="${SPKI_ROOT}/scheme/chez/spki-authz.sps"
SPKI_CHEZ_AUDIT_SCRIPT="${SPKI_ROOT}/scheme/chez/spki-audit.sps"
SPKI_CHEZ_VAULT_SCRIPT="${SPKI_ROOT}/scheme/chez/spki-vault.sps"
EOF
}

resolve_node_name() {
  local id="$1"
  local fallback="node${id}"
  local csv="${SPKI_REALM_HARNESS_NODE_NAMES:-}"
  if [[ -z "$csv" ]]; then
    printf "%s" "$fallback"
    return 0
  fi

  local index=$((id - 1))
  local raw
  IFS=',' read -r -a names <<<"$csv"
  if (( index < 0 || index >= ${#names[@]} )); then
    printf "%s" "$fallback"
    return 0
  fi

  raw="${names[$index]}"
  raw="${raw#"${raw%%[![:space:]]*}"}"
  raw="${raw%"${raw##*[![:space:]]}"}"
  if [[ -z "$raw" ]]; then
    printf "%s" "$fallback"
    return 0
  fi
  printf "%s" "$raw"
}

load_node_env() {
  local id="$1"
  local env_file
  env_file="$(node_env_file "$id")"
  if [[ ! -f "$env_file" ]]; then
    echo "Error: node env not found: $env_file" >&2
    echo "Run: $(basename "$0") init" >&2
    exit 1
  fi
  # shellcheck disable=SC1090
  source "$env_file"
}

ensure_build() {
  if ! command -v dune >/dev/null 2>&1; then
    echo "Error: dune not found. Install with: opam install dune" >&2
    exit 1
  fi
  log_event "info" "harness.build" "start" "building SPKI binaries"
  echo "Building SPKI binaries..."
  (cd "$SPKI_ROOT" && dune build)
  log_event "info" "harness.build" "ok" "build complete"
}

run_realm_for_node() {
  local id="$1"
  shift
  load_node_env "$id"
  local realm_bin
  local node_log
  realm_bin="$(resolve_spki_bin spki_realm)"
  node_log="$(node_dir "$id")/logs/realm.log"
  mkdir -p "$(dirname "$node_log")"
  log_event "info" "harness.realm_command" "start" "node=${id} args=$*"
  (
    cd "$SPKI_ROOT"
    SPKI_REALM_WORKDIR="$SPKI_REALM_WORKDIR" \
    SPKI_KEY_DIR="$SPKI_KEY_DIR" \
    SPKI_CHEZ_LIBDIR="$SPKI_CHEZ_LIBDIR" \
    SPKI_CHEZ_SCRIPT="$SPKI_CHEZ_SCRIPT" \
    SPKI_REALM_BIN="$realm_bin" \
    SPKI_REQUEST_ID="${SPKI_REQUEST_ID:-}" \
    "$realm_bin" "$@" \
      > >(tee -a "$node_log") \
      2> >(tee -a "$node_log" >&2)
  )
  log_event "info" "harness.realm_command" "ok" "node=${id}"
}

cmd_init() {
  local count="${1:-$DEFAULT_NODES}"
  if ! [[ "$count" =~ ^[0-9]+$ ]] || (( count < 1 )); then
    echo "Error: node count must be a positive integer" >&2
    exit 1
  fi
  log_event "info" "harness.init" "start" "nodes=${count}"
  ensure_build
  mkdir -p "$HARNESS_ROOT"
  for id in $(seq 1 "$count"); do
    write_node_env "$id"
    run_realm_for_node "$id" --json --status >/dev/null || true
  done
  echo "Initialized ${count} nodes under ${HARNESS_ROOT}"
  echo "Next: $(basename "$0") status ${count}"
  log_event "info" "harness.init" "ok" "nodes=${count}"
}

cmd_status() {
  local count="${1:-$DEFAULT_NODES}"
  log_event "info" "harness.status" "start" "nodes=${count}"
  for id in $(seq 1 "$count"); do
    echo "=== node${id} ==="
    run_realm_for_node "$id" --json --status || true
  done
  log_event "info" "harness.status" "ok" "nodes=${count}"
}

cmd_self_join() {
  local count="${1:-$DEFAULT_NODES}"
  if (( count < 1 )); then
    echo "Need at least 1 node for self-join" >&2
    exit 1
  fi
  log_event "info" "harness.self_join" "start" "nodes=${count}"
  echo "Self-joining node1 -> ${DEFAULT_MASTER_HOST}:${DEFAULT_MASTER_PORT}"
  load_node_env 1
  run_realm_for_node 1 --json --join --name "$SPKI_NODE_NAME" --host "$DEFAULT_MASTER_HOST" --port "$DEFAULT_MASTER_PORT"
  log_event "info" "harness.self_join" "ok" "node=1"
}

cmd_invite_all() {
  local count="${1:-$DEFAULT_NODES}"
  if (( count < 2 )); then
    echo "Need at least 2 nodes for invite-all" >&2
    exit 1
  fi
  log_event "info" "harness.invite_all" "start" "nodes=${count}"
  for id in $(seq 2 "$count"); do
    load_node_env "$id"
    echo "Inviting/joining node${id} -> ${DEFAULT_MASTER_HOST}:${DEFAULT_MASTER_PORT}"
    run_realm_for_node "$id" --json --join --name "$SPKI_NODE_NAME" --host "$DEFAULT_MASTER_HOST" --port "$DEFAULT_MASTER_PORT"
  done
  log_event "info" "harness.invite_all" "ok" "nodes=${count}"
}

cmd_ui() {
  local id="${1:-}"
  if [[ -z "$id" ]]; then
    echo "Usage: $(basename "$0") ui <NODE_ID>" >&2
    exit 1
  fi
  local env_file
  env_file="$(node_env_file "$id")"
  if [[ ! -f "$env_file" ]]; then
    echo "Error: node env not found: $env_file" >&2
    echo "Run: $(basename "$0") init" >&2
    exit 1
  fi
  log_event "info" "harness.ui" "start" "node=${id}"
  SPKI_ENV_FILE="$env_file" SPKI_SKIP_BUILD=1 "$SCRIPT_DIR/run-local.sh"
  log_event "info" "harness.ui" "ok" "node=${id}"
}

cmd_ui_all_bg() {
  local count="${1:-$DEFAULT_NODES}"
  local ui_binary="${UI_ROOT}/.build/debug/CyberspaceMac"
  log_event "info" "harness.ui_all_bg" "start" "nodes=${count}"
  if [[ ! -x "$ui_binary" ]]; then
    log_event "info" "harness.ui_all_bg.prebuild" "start" "building CyberspaceMac once before background launch"
    (
      cd "$UI_ROOT"
      swift build -c debug --product CyberspaceMac
    )
    log_event "info" "harness.ui_all_bg.prebuild" "ok" "ui binary ready"
  fi
  for id in $(seq 1 "$count"); do
    local env_file log_file pid_file
    env_file="$(node_env_file "$id")"
    log_file="$(node_dir "$id")/logs/node.log"
    pid_file="$(node_dir "$id")/logs/ui.pid"
    if [[ ! -f "$env_file" ]]; then
      echo "Error: node env not found: $env_file" >&2
      echo "Run: $(basename "$0") init ${count}" >&2
      exit 1
    fi
    if [[ -f "$pid_file" ]]; then
      local existing_pid
      existing_pid="$(cat "$pid_file" 2>/dev/null || true)"
      if [[ -n "$existing_pid" ]] && kill -0 "$existing_pid" >/dev/null 2>&1; then
        echo "node${id} UI already running as PID ${existing_pid} (log: $log_file)"
        continue
      fi
    fi
    SPKI_ENV_FILE="$env_file" SPKI_SKIP_BUILD=1 SPKI_SKIP_UI_BUILD=1 SPKI_REQUEST_ID="${SPKI_REQUEST_ID:-}" "$SCRIPT_DIR/run-local.sh" >"$log_file" 2>&1 &
    echo "$!" >"$pid_file"
    echo "node${id} UI PID $! (log: $log_file)"
    log_event "info" "harness.ui_all_bg" "ok" "node=${id} pid=$!"
  done
}

cmd_stop_all_bg() {
  local count="${1:-$DEFAULT_NODES}"
  log_event "info" "harness.stop_all_bg" "start" "nodes=${count}"
  for id in $(seq 1 "$count"); do
    local log_file pid_file
    log_file="$(node_dir "$id")/logs/node.log"
    pid_file="$(node_dir "$id")/logs/ui.pid"
    if [[ ! -f "$pid_file" ]]; then
      echo "node${id} no PID file (already stopped)"
      continue
    fi

    local pid
    pid="$(cat "$pid_file" 2>/dev/null || true)"
    if [[ -z "$pid" ]]; then
      rm -f "$pid_file"
      echo "node${id} PID file empty (cleaned)"
      continue
    fi

    if kill -0 "$pid" >/dev/null 2>&1; then
      kill "$pid" >/dev/null 2>&1 || true
      echo "node${id} stopped PID ${pid} (log: $log_file)"
    else
      echo "node${id} PID ${pid} not running (cleaned)"
    fi
    rm -f "$pid_file"
  done
  log_event "info" "harness.stop_all_bg" "ok" "nodes=${count}"
}

cmd_env() {
  local id="${1:-}"
  if [[ -z "$id" ]]; then
    echo "Usage: $(basename "$0") env <NODE_ID>" >&2
    exit 1
  fi
  node_env_file "$id"
}

cmd_clean() {
  log_event "info" "harness.clean" "start" "root=${HARNESS_ROOT}"
  rm -rf "$HARNESS_ROOT"
  echo "Removed $HARNESS_ROOT"
}

main() {
  local cmd="${1:-}"
  shift || true
  case "$cmd" in
    init) cmd_init "$@" ;;
    status) cmd_status "$@" ;;
    self-join) cmd_self_join "$@" ;;
    invite-all) cmd_invite_all "$@" ;;
    join-all) cmd_invite_all "$@" ;;
    ui) cmd_ui "$@" ;;
    ui-all-bg) cmd_ui_all_bg "$@" ;;
    stop-all-bg) cmd_stop_all_bg "$@" ;;
    env) cmd_env "$@" ;;
    clean) cmd_clean ;;
    ""|-h|--help|help) usage ;;
    *)
      echo "Unknown command: $cmd" >&2
      usage
      exit 1
      ;;
  esac
}

main "$@"
